---
title: "Compare 3 Clustering methods for Method Consensus using inverse normally transformed (INT) data"
author: "Kelly Brewer, HC clustering by MD and RS"
date: "`r Sys.Date()`"
output: 
  html_document:
    toc: true
    toc_depth: 3
    df_print: paged
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

This file uses 3 clustering methods to compare which cluster group each of the PCOS cohort subjects would fall into given each of the 3 methods. Cluster methods use 8 traits and include:
  1) Hierarchical Clustering (stats package)- connectivity-based clustering
  2) K-means Clustering (stats package)- centroid-based clustering #this is different than previous flexclust package, chosen to be able to run Jaccard scores using same package as performed on HC
  3) Gaussian mixture models (ClusterR package)- distribution-based clustering

Definitions:  
Consensus = 2 out of 3 methods agree on subgroup  
Strong Consensus = 3 out of 3 methods agree on subgroup

***

## Input Data Fields and Structure

```{r read_data, eval=TRUE, echo=FALSE, error=FALSE, message=FALSE, warning=FALSE}
rm(list = ls())
library(tidyverse)
library(ggrepel)
library(tidymodels)
library(reshape2)
library(factoextra)
library(FactoMineR)
library(ClusterR)
library(fpc)
library(stats)
library(gplots)
#library(clusterSim)
library(describedata)
library(lattice)
library(corrplot)
library(DT)
library(ggradar)
library(qwraps2)
options(qwraps2_markup = "markdown")
library(Hmisc)
library(ggstatsplot)

################################################
# Functions                                    #
################################################
## Reverse normal transformation
rntransform <- function(y) {
  out <- rank(y)
  out[is.na(y)] <- NA
  qnorm((out - 0.5) / max(out, na.rm=T))
}

################################################
# Variables                                    #
################################################

## Path/file of the input file, which must have columns according to
## cluster_input_cols below.
input_file <- "path/to/input/text/file/SampleData.txt"

## Names of sample ID, age, bmi, and the other 7 traits
sample <- 'sample_id'; age <- 'age'; bmi <- 'bmi'
traitnames = c('T', 'dheas', 'i0', 'g0', 'shbg', 'lh', 'fsh')

## variable names for displaying/plotting results
var_labels <- c('BMI', 'T', 'DHEAS', 'Ins0', 'Glu0', 'SHBG', 'LH', 'FSH')

## The assay method for each of the 7 traits is another variable, named by
## adding a postfix to the trait name.  The postfix in our data is
## '_assay_method'.  For example, dheas_assay_method.
assay <- '_assay_method'

## columns of the input file
cluster_input_cols <- c(sample, age, bmi,
                        traitnames,
                        paste0(traitnames, assay))
## columns of variables (some to be defined later) for clustering
d <- '.'
cluster_cols <- c(sample, age,
                  paste(c(bmi, traitnames), 'z', sep=d))

## Methods for distance calculation and for hierarchical clustering.
## Our initial analysis used manhattan distance and ward.D clustering method.
dist_metric <- 'manhattan'
clust_method <- 'ward.D'

## Read in input file (must have columns according to cluster_input_cols)
m.df0 <- read.delim(input_file, na.strings=c("", "#N/A", "missing"))
str(m.df0)
```

***
## Remove duplicates, outliers and missing data
```{r remove_dupes_incomplete, eval=TRUE, echo=FALSE, error=FALSE, message=TRUE}
## Remove duplicate entries (keep the first occurrence for each set of duplicates)
dupidx = duplicated(m.df0[, cluster_input_cols[1:(3+length(traitnames))]])
if(sum(dupidx)>0) warning(paste("Removing", sum(dupidx), "duplicates from data"))
m.df <- m.df0[!dupidx,]

## Only keep samples with complete, non-zero data for age and the 8 traits
completeidx = complete.cases(m.df[, c(age, bmi, traitnames)])
if(sum(!completeidx)>0) {
    warning(paste("Removing", sum(!completeidx), "records due to incomplete data"))
    for(ii in c(age, bmi, traitnames)) {
        tmpidx = complete.cases(m.df[, ii])
        if(sum(!tmpidx)>0) message(paste(ii, "has", sum(!tmpidx), "missing records"))
    }
    m.df <- m.df[completeidx, ]
}

message(paste("There are",nrow(m.df), "cases remaining in the dataset after removal of incomplete cases."))
```

***
## Flagging Outliers and Removing
```{r outliers_removal, eval=TRUE, echo=FALSE, error=FALSE, message=TRUE}

# Create variables for removal flag flags and set them == 0
trait.rem.flags = c()
for (var in traitnames) {
  names <- c(paste0(var, '_rem_flag', sep=''))
  trait.rem.flags[[names]] <- names
}
trait.rem.flags <- as.character(trait.rem.flags)
for (var in trait.rem.flags) {
  m.df[,var] <- 0
}

#g0 Removal
m.df$g0_rem_flag <- ifelse(m.df$g0 > 126, 1, 0)

# Add in any additional removals
# m.df$shbg_rem_flag <- ifelse(m.df$shbg > 200 & m.df$shbg_assay_method != 1, 1, 0)
# m.df$lh_rem_flag <- ifelse(m.df$lh > 50, 1, 0)
# m.df$fsh_rem_flag <- ifelse(m.df$fsh > 40, 1, 0)


for (var in traitnames) {
  x <- paste0(var,"_rem_flag")
  if(sum(m.df[,x]) > 0) message(paste(var, "has", sum(m.df[,x]), "records removed as outliers."))
}

m.df.removed <- filter(m.df, if_any(all_of(trait.rem.flags), ~ . == 1))
removed.path <- 'path/to/Subtyping_Removed_Outliers.txt'
#write.table(m.df.removed, removed.path, sep = '\t', row.names = F, quote = F)
#message(paste0('Outliers removed from dataset written to: ', removed.path))

for (var in traitnames) {
  x <- paste0(var,"_rem_flag")
  m.df[,var] <- ifelse(m.df[,x] == 1, NA, m.df[,var])
}

## Only keep samples with complete, non-zero data for age and the 8 traits
completeidx = complete.cases(m.df[, c(age, bmi, traitnames)])
if(sum(!completeidx)>0) {
    warning(paste("Removing", sum(!completeidx), "records records containing outliers"))
    m.df <- m.df[completeidx, ]
}

message(paste("There are",nrow(m.df), "cases remaining in the dataset after outliers were removed."))
```

### Adjust BMI and 7 traits by Age, then apply reverse normal transformation
```{r adjust_normalize, eval=TRUE, echo=FALSE, error=FALSE, message=TRUE}
################################################
# Adjust BMI and 7 other traits               #
# Then apply reverse normal transformation      #
################################################

## Adjust log(BMI) for age, obtain the residual.
m.df$bmi.z <- log(m.df$bmi)
model <- lm(bmi.z ~ age, data=m.df)
m.df$bmi.z <- resid(model)

## For the other 7 traits, adjust log(trait) for age and assay method (if
## there are more than one method), obtain the residual.
for (var in traitnames) {
  method <- paste0(var, assay)
  z <- paste(var, 'z', sep=d)
  m.df[,method] <- as.factor(as.character(m.df[,method]))
  m.df[, z] <- log(m.df[, var])
  if (nlevels(m.df[,method]) > 1) {
    model <- lm(as.formula(paste(z, '~', age, '+', method)), data=m.df)
  } else {
    model <- lm(as.formula(paste(z, '~', age)), data=m.df)
  }
  m.df[, z] <-  resid(model)
}

## Apply the inverse normal transformation to the residuals
for (col in cluster_cols[3:length(cluster_cols)]) {
  #print(c(col,shapiro.test(m.df[,col])[[2]] ))
  m.df[!is.na(m.df[,col]), col] <- rntransform(m.df[!is.na(m.df[,col]), col])
}
```

***
```{r create_clust_df, eval=TRUE, echo=FALSE, error=FALSE, message=TRUE}
# Display number of subjects being included after removals

m.df2 <- m.df[, cluster_cols]
names(m.df2) <- c(sample, age, var_labels)
```

***
```{r correlation, eval=TRUE, echo=FALSE, error=FALSE, message=TRUE}
corrplot(cor(m.df2[3:10]), method = 'number', type = 'lower')
```

***
### Hierarchical Clustering

```{r perform_clustering, eval=TRUE, echo=FALSE, error=FALSE, message=TRUE}
## Hierarchical clustering on the columns
cluster_matrix <- as.matrix(na.omit(m.df2[, var_labels]))
hc <- hclust(dist(cluster_matrix, method=dist_metric), method=clust_method)

## Hierarchical clustering on the rows
df.12 <- as.matrix(na.omit(m.df2[, var_labels]))
row_hc <- hclust(dist(t(df.12), method=dist_metric), method=clust_method)

## Define clusters (k=3 means we define 3 clusters)
mycl <- cutree(hc, k=3)

## Get clustering stats
stats <- cluster.stats(dist(cluster_matrix, method=dist_metric), mycl)

## Add the cluster ID# to your data and relabel the clusters
clusters <- as.data.frame(cbind(cluster_matrix, cluster_id=mycl))
```

```{r relabel_clusters, eval=TRUE, echo=FALSE, error=FALSE, message=TRUE, warning=FALSE}
#Label clusters by name
centroids <- clusters %>%
  group_by(cluster_id) %>%
  summarise_all(funs(mean))
centroids.met <- centroids[,c('BMI', 'Ins0', 'Glu0')]
centroids.rep <- centroids[,c('SHBG', 'LH')] #removed FSH because Rep and Bkg flip flop with FSH centroid included. 
met <- which.max(rowSums(centroids.met))
rep <- which.max(rowSums(centroids.rep))

clusters$cluster_new <- ifelse(clusters$cluster==met, 10,
                               ifelse(clusters$cluster==rep, 11, 12))
clusters$cluster_id <- ifelse(clusters$cluster_new==10, 1,
                              ifelse(clusters$cluster_new==11, 2, 3))

clusters$cluster_new = NULL  ## remove this temporary column
clusters$cluster = NULL ##remove original cluster number

clusters$group <- ifelse(clusters$cluster_id==1, "Metabolic",
                         ifelse(clusters$cluster_id==2, "Reproductive", "Background"))

## Apply updated cluster ID's an updated variable 'mycl_upd' that was generated from the 
## cuttree function after pruning to 3 from the hierarchical clustering
hc_mycl <- clusters$cluster_id

## Merge the sample_ids
clusters <- merge(clusters, m.df2, by=var_labels)

hc_clusters = clusters
```

```{r clustering_stats, eval=TRUE, echo=FALSE, error=FALSE, message=TRUE}
hc_stats <- cluster.stats(dist(cluster_matrix, method=dist_metric), hc_mycl)
```

```{r hc_jaccard, eval=TRUE, echo=TRUE, error=FALSE, message=FALSE, results='hide'}
##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
##   Calculate Cluster Stability (Jaccard Scores) using Bootstrapping Method----
##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
cboot.hclust <- clusterboot(dist(cluster_matrix, method=dist_metric),
                            B=1000, clustermethod=disthclustCBI,
                            method=clust_method, k=3)


## Relabel bootmean values as these are based off ordering in the original cluster ID labels.
jaccard_score <- as.list(cboot.hclust$bootmean)
```

***
### Hierarchical Clustering Summary
```{r hc_table_clust, eval=TRUE, echo=FALSE, error=FALSE, message=TRUE}
##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
##              Summary Table of Hierarchical Clustering Results            ----
##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tab_cnt <- c(sum(hc_mycl == 2), 
             sum(hc_mycl == 1),  
             sum(hc_mycl == 3))

tab_perc <- c(round(sum(hc_mycl == 2)/length(hc_mycl),4)*100,
              round(sum(hc_mycl == 1)/length(hc_mycl),4)*100, 
              round(sum(hc_mycl == 3)/length(hc_mycl),4)*100)

tab_jac <- c(jaccard_score[rep],
             jaccard_score[met], 
             jaccard_score[-c(met, rep)])

tab_jac <- lapply(tab_jac, round, 2)

tab <- rbind(tab_cnt, tab_perc, tab_jac)
colnames(tab) <- c('Reproductive', 'Metabolic', 'Background')
rownames(tab) <- c('HC-Count', 'HC-Percent', 'Hc-Jaccard Index')

datatable(tab, options = list(dom = 't', columnDefs = list(list(className = 'dt-center', targets = 1:3))))
```

```{r alt_jaccard, eval=TRUE, echo=FALSE, error=FALSE, message=FALSE, results='hide'}

### try bootstapping without distance metric, use only the INT data ###Not as good as dist

##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
##   Calculate Cluster Stability (Jaccard Scores) using Bootstrapping Method----
##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# cboot.hclust <- clusterboot(cluster_matrix,
#                             B=1000, clustermethod=hclustCBI,
#                             method=clust_method, k=3)
# 
# ## Relabel bootmean values as these are based off ordering in the original cluster ID labels.
# jaccard_score <- as.list(cboot.hclust$bootmean)

###Jaccard: Met=0.54, Rep=0.37, Bkg=0.4
#prv_Jacrd: Met= 0.63, Rep=0.54, Bkg=0.32
```
***

### HC Boxplots of Normalized Traits by Cluster
```{r boxplots, eval=TRUE, echo=FALSE, error=FALSE, message=FALSE, warning=FALSE, out.width= "110%"}
################################################
# Boxplots of the traits by cluster            #
################################################

hc.melt <- melt(hc_clusters[1:9], id.var = "cluster_id")

sorted_vars <- var_labels
plot_labels <- c('Ins0', 'BMI', 'Glu0', 'DHEAS', 'T', 'FSH', 'LH', 'SHBG')
hc.melt$variable <- factor(hc.melt$variable, levels = c('Ins0', 'BMI', 'Glu0', 'DHEAS', 'T', 'FSH', 'LH', 'SHBG'))


ggplot(data = hc.melt, aes(x=variable, y=value, fill=as.factor(cluster_id))) + geom_boxplot(outlier.shape = NA, coef = 0) +
  scale_fill_manual(labels = c("Metabolic", "Reproductive", "Background"), values=c(rgb(0.81,0.3,0.25,.85), rgb(.33,.5,.77,1), 'grey'), name = "") + ylim(-2,2) + 
  theme_bw() +
  theme(legend.position = "bottom", legend.box = "horizontal", 
        axis.title.x=element_blank()) + ylab("Z") + ggtitle("HC")
```

```{r updatelabel, eval=TRUE, echo=FALSE, error=FALSE, message=TRUE}
## Re-order the data frame
col_idx <- grep("cluster_id", names(hc_clusters))
hc_clusters <- hc_clusters[, c(col_idx, (1:ncol(hc_clusters))[-col_idx])]
col_idx <- grep(sample, names(hc_clusters))
hc_clusters <- hc_clusters[, c(col_idx, (1:ncol(hc_clusters))[-col_idx])]

## Write output table
#write.csv(hc_clusters, "path/to/HC_clusters.csv")
```

***
### PCA Plot of Cluster Results
```{r pca_plots, eval=TRUE, echo=FALSE, error=FALSE, message=TRUE}

################################################
# PCA plots overlay the clusters               #
################################################

### PCA PLOT ###
hc_clusters$cluster_id <- as.factor(hc_clusters$cluster_id)
hc_clusters$group <- ifelse(hc_clusters$cluster_id==1, "Metabolic", ifelse(hc_clusters$cluster_id==2, "Reproductive", "Background"))

pca <- PCA(hc_clusters[3:10], graph = F)

# If plot is mirrored from example, multiply PC1 by -1 to reverse image to maintain consistency.

#pca$ind$coord[,1] <- pca$ind$coord[,1]*-1
#pca$var$coord[,1] <- pca$var$coord[,1]*-1

fviz_pca_biplot(pca, col.ind = hc_clusters$group, palette = c('grey', rgb(0.81,0.3,0.25,.85), rgb(.33,.5,.77,1)),
                addEllipses = TRUE, label = "var", col.var = "black", repel = TRUE,
                legend.title = "Subtype", pointsize=2,#pointshape=19,
                xlab = paste("PC1 (", round(pca$eig[1,2],2), '%)', sep=''),
                ylab = paste("PC2 (", round(pca$eig[2,2],2), '%)', sep=''),
                title = "HC")
#dev.off()
```

***
## Kmeans clustering
```{r Kmeans, echo=FALSE, error=FALSE, message=FALSE, warning=FALSE}

set.seed(123)
#km.res <- stats::kmeans(cluster_matrix, 3, nstart = 25) #Euclidean distance metric used
km.res <- stats::kmeans(dist(cluster_matrix, method=dist_metric), 3, nstart = 25) #uses manhattan distance, otherwise Kmeans defaults to Euclidean

## Get clustering stats
km_stats <- cluster.stats(dist(cluster_matrix, method=dist_metric),  km.res$cluster)

#get Dunn Index to define seperation in the clusters
#km_stats$dunn

#get silhouette for each cluster
#km_stats$avg.silwidth
#km_stats$clus.avg.silwidths

clusters = m.df2[c(3:10)]
clusters$cluster_id <- km.res$cluster
clusters$cluster_id<-as.character(clusters$cluster_id)

#Label clusters by name
centroids <- clusters %>%
  group_by(cluster_id) %>%
  summarise_all(funs(mean))
centroids.met <- centroids[,c('BMI', 'Ins0', 'Glu0')]
centroids.rep <- centroids[,c('SHBG', 'LH')] #maintain same naming convention as HC for consistency
met <- which.max(rowSums(centroids.met))
rep <- which.max(rowSums(centroids.rep))

clusters$cluster_new <- ifelse(clusters$cluster==met, 10,
                               ifelse(clusters$cluster==rep, 11, 12))
clusters$cluster_id <- ifelse(clusters$cluster_new==10, 1,
                              ifelse(clusters$cluster_new==11, 2, 3))

clusters$cluster_new = NULL  ## remove this temporary column
clusters$cluster = NULL ##remove original cluster number

clusters$group <- ifelse(clusters$cluster_id==1, "Metabolic",
                         ifelse(clusters$cluster_id==2, "Reproductive", "Background"))

## Apply updated cluster ID's an updated variable 'mycl_upd' that was generated from the 
## cuttree function after pruning to 3 from the hierarchical clustering
km_mycl <- clusters$cluster_id

## Merge the sample_ids
clusters <- merge(clusters, m.df2, by=var_labels)

km_clusters = clusters
```

```{r km_jaccard, echo=TRUE, eval=TRUE, error=FALSE, message=FALSE, results='hide'}

###This step will take some time. 

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#   Calculate Cluster Stability (Jaccard Scores) using Bootstrapping Method----
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
cboot.kmeans <- clusterboot(dist(cluster_matrix, method=dist_metric), distances = TRUE, runs= 100, iter.max= 100,
                            clustermethod=kmeansCBI,
                            krange=3, seed =123)

#Relabel bootmean values as these are based off ordering in the original cluster ID labels.
jaccard_score <- as.list(cboot.kmeans$bootmean)

###Running bootstrap of cluster matrix produces jaccard index of Euclidean distances, need to change to dist(cluster_matrix) in order to bootstrap the manhattan distances. 

###INFO: Jaccard results of dist(cluster_matrix)
#        Met= 0.94, Rep= 0.93, Bkg= 0.95
###INFO: Jaccard results of cluster_matrix
#        Met= 0.81, Rep= 0.83, Bkg= 0.92
```

***
### Kmeans Clustering Summary
```{r km_table_clust, eval=TRUE, echo=FALSE, error=FALSE, message=TRUE}
##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
##              Summary Table of Hierarchical Clustering Results            ----
##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tab_cnt <- c(sum(km_mycl == 2),
             sum(km_mycl == 1), 
             sum(km_mycl == 3))

tab_perc <- c(round(sum(km_mycl == 2)/length(km_mycl),4)*100,
              round(sum(km_mycl == 1)/length(km_mycl),4)*100,
              round(sum(km_mycl == 3)/length(km_mycl),4)*100)

tab_jac <- c(jaccard_score[rep],
             jaccard_score[met],
             jaccard_score[-c(met, rep)])

tab_jac <- lapply(tab_jac, round, 2)

tab <- rbind(tab_cnt, tab_perc, tab_jac)
colnames(tab) <- c('Reproductive', 'Metabolic', 'Background')
rownames(tab) <- c('Km-Count', 'Km-Percent', 'Km-Jaccard Index')

datatable(tab, options = list(dom = 't', columnDefs = list(list(className = 'dt-center', targets = 1:3))))
```

***
### Km Boxplots of Normalized Traits by Cluster
```{r km_boxplots, eval=TRUE, echo=FALSE, error=FALSE, message=FALSE, warning=FALSE, out.width= "110%"}
################################################
# Boxplots of the traits by cluster            #
################################################

km.melt <- melt(km_clusters[1:9], id.var = "cluster_id")

sorted_vars <- var_labels
plot_labels <- c('Ins0', 'BMI', 'Glu0', 'DHEAS', 'T', 'FSH', 'LH', 'SHBG')
km.melt$variable <- factor(km.melt$variable, levels = c('Ins0', 'BMI', 'Glu0', 'DHEAS', 'T', 'FSH', 'LH', 'SHBG'))


ggplot(data = km.melt, aes(x=variable, y=value, fill=as.factor(cluster_id))) + geom_boxplot(outlier.shape = NA, coef = 0) +
  scale_fill_manual(labels = c("Metabolic", "Reproductive", "Background"), values=c(rgb(0.81,0.3,0.25,.85), rgb(.33,.5,.77,1), 'grey'), name = "") + ylim(-2,2) + 
  theme_bw() +
  theme(legend.position = "bottom", legend.box = "horizontal", 
        axis.title.x=element_blank()) + ylab("Z") + ggtitle("Kmeans")
```

```{r km_updatelabel, eval=TRUE, echo=FALSE, error=FALSE, message=TRUE}
## Re-order the data frame
col_idx <- grep("cluster_id", names(km_clusters))
km_clusters <- km_clusters[, c(col_idx, (1:ncol(km_clusters))[-col_idx])]
col_idx <- grep(sample, names(km_clusters))
km_clusters <- km_clusters[, c(col_idx, (1:ncol(km_clusters))[-col_idx])]

## Write output table
#write.csv(km_clusters, "path/to/Km_clusters.csv")
```

***
### PCA Plot of Cluster Results
```{r km_pca_plots, eval=TRUE, echo=FALSE, error=FALSE, message=TRUE}

################################################
# PCA plots overlay the clusters               #
################################################

### PCA PLOT ###
km_clusters$cluster_id <- as.factor(km_clusters$cluster_id)
km_clusters$group <- ifelse(km_clusters$cluster_id==1, "Metabolic", ifelse(km_clusters$cluster_id==2, "Reproductive", "Background"))

pca <- PCA(km_clusters[3:10], graph = F)

# If plot is mirrored from example, multiply PC1 by -1 to reverse image to
# maintain consistency.

#pca$ind$coord[,1] <- pca$ind$coord[,1]*-1
#pca$var$coord[,1] <- pca$var$coord[,1]*-1

fviz_pca_biplot(pca, col.ind = km_clusters$group, palette = c('grey', rgb(0.81,0.3,0.25,.85), rgb(.33,.5,.77,1)),
                addEllipses = TRUE, label = "var", col.var = "black", repel = TRUE,
                legend.title = "Subtype", pointsize=2,#pointshape=19,
                xlab = paste("PC1 (", round(pca$eig[1,2],2), '%)', sep=''),
                ylab = paste("PC2 (", round(pca$eig[2,2],2), '%)', sep=''),
                title = "Kmeans")
#dev.off()
```

```{r, km_compare clusters, echo=FALSE, error=FALSE, message=FALSE, warning=FALSE}
hc_clusters = hc_clusters %>% rename(hc_group = group) 
km_clusters = km_clusters %>% rename(km_group = group) 
cluster_compare <- merge(hc_clusters[c(1,3:11)], km_clusters[c(1,11)], by='sample_id')
cluster_compare$hc_group <- factor(cluster_compare$hc_group, levels = c('Reproductive', 'Metabolic', 'Background'))
cluster_compare$km_group <- factor(cluster_compare$km_group, levels = c('Reproductive', 'Metabolic', 'Background'))

gmodels::CrossTable(cluster_compare$hc_group, cluster_compare$km_group, digits=2, prop.r = TRUE, prop.c =TRUE,
           prop.t= FALSE, prop.chisq = FALSE, chisq =FALSE, fisher =FALSE, missing.include=FALSE)

cluster_colors = c('#5480C4FF','#CF4D40D9','grey')

ggplot2::ggplot(cluster_compare, aes(fill = km_group, x=hc_group)) +
  geom_bar() +
  scale_fill_manual(values = cluster_colors) +
  ggtitle("HC Subtype Bars with Kmeans Subtype Color Fill")

## Write output table
#write.csv(cluster_compare, "path/to/HC_Km_Con_clusters.csv") 

consensus = function(x, len=2) {
    temp = sort(table(x), decreasing=T)
    ifelse(temp[1]>len/2, names(temp)[1], NA)
}

cluster_compare = cbind(cluster_compare, HCKmCon=apply(cluster_compare[c(10,11)], 1, consensus))

table(cluster_compare$HCKmCon)
```

***
## Gaussian Mixed Models clustering
```{r Gaussian, echo=FALSE, error=FALSE, message=FALSE, warning=FALSE}

library(ClusterR)

m.df_gmm <- m.df2[3:10]
gmm <- GMM(m.df_gmm, 3, dist_mode = "maha_dist", seed_mode = "random_subset", km_iter =10, em_iter = 100, verbose =F) 
#seed_mode= initial centroids
#tried multiple iterations. 1000 for both is 99% same as 100. 100 better. Large PCA shift btwn 50 and 100. 100 shows better separation in PCA plot. 

pr= predict_GMM(m.df_gmm, gmm$centroids, gmm$covariance_matrices, gmm$weights)

m.df_gmm$cluster_id <- pr$cluster_labels

gmm_stats <- cluster.stats(dist(cluster_matrix, method=dist_metric), pr$cluster_labels)

#get Dunn Index to define seperation in the clusters
#gmm_stats$dunn

#get silhouette for each cluster
#gmm_stats$avg.silwidth
#gmm_stats$clus.avg.silwidths

clusters = m.df_gmm
clusters$cluster_id<-as.character(clusters$cluster_id)

#Label clusters by name
centroids <- clusters %>%
  group_by(cluster_id) %>%
  summarise_all(funs(mean))
centroids.met <- centroids[,c('BMI', 'Ins0', 'Glu0')]
centroids.rep <- centroids[,c('SHBG', 'LH')] #same naming convention as in other methods
met <- which.max(rowSums(centroids.met))
rep <- which.max(rowSums(centroids.rep))

clusters$cluster_new <- ifelse(clusters$cluster==met, 10,
                               ifelse(clusters$cluster==rep, 11, 12))
clusters$cluster_id <- ifelse(clusters$cluster_new==10, 1,
                              ifelse(clusters$cluster_new==11, 2, 3))

clusters$cluster_new = NULL  ## remove this temporary column
clusters$cluster = NULL ##remove original cluster number

clusters$group <- ifelse(clusters$cluster_id==1, "Metabolic",
                         ifelse(clusters$cluster_id==2, "Reproductive", "Background"))

## Apply updated cluster ID's an updated variable 'mycl_upd' that was generated from the 
## cuttree function after pruning to 3 from the hierarchical clustering
gmm_mycl <- clusters$cluster_id

## Merge the sample_ids
clusters <- merge(clusters, m.df2, by=var_labels)

gmm_clusters = clusters
```

### GMM Jaccard
```{r gmm_jaccard, eval=TRUE, echo=TRUE, error=FALSE, message=FALSE, results='hide'}

###This will take some time. 

##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
##   Calculate Cluster Stability (Jaccard Scores) using Bootstrapping Method----
##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
cboot.gmm <- clusterboot(dist(cluster_matrix, method=dist_metric), k=3, multipleboot= FALSE,
                            clustermethod=distnoisemclustCBI, nnk=0) #distnoisemclust assume dissimilarity matrix as input

# Relabel bootmean values as these are based off ordering in the original cluster ID labels.
jaccard_score <- as.list(cboot.gmm$bootmean)
```

***
### GMM Clustering Summary
```{r gmm_table_clust, eval=TRUE, echo=FALSE, error=FALSE, message=TRUE}
##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
##              Summary Table of Hierarchical Clustering Results            ----
##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tab_cnt <- c(sum(gmm_mycl == 2),
             sum(gmm_mycl == 1), 
             sum(gmm_mycl == 3))

tab_perc <- c(round(sum(gmm_mycl == 2)/length(gmm_mycl),4)*100,
              round(sum(gmm_mycl == 1)/length(gmm_mycl),4)*100,
              round(sum(gmm_mycl == 3)/length(gmm_mycl),4)*100)

tab_jac <- c(jaccard_score[rep],
             jaccard_score[met],
             jaccard_score[-c(met, rep)])

tab_jac <- lapply(tab_jac, round, 2)

tab <- rbind(tab_cnt, tab_perc, tab_jac)
colnames(tab) <- c('Reproductive', 'Metabolic', 'Background')
rownames(tab) <- c('GMM-Count', 'GMM-Percent', 'GMM-Jaccard Index')

datatable(tab, options = list(dom = 't', columnDefs = list(list(className = 'dt-center', targets = 1:3))))
```

***
### GMM Boxplots of Normalized Traits by Cluster
```{r gmm_boxplots, eval=TRUE, echo=FALSE, error=FALSE, message=FALSE, warning=FALSE, out.width= "110%"}
################################################
# Boxplots of the traits by cluster            #
################################################

gmm.melt <- melt(gmm_clusters[1:9], id.var = "cluster_id")

sorted_vars <- var_labels
plot_labels <- c('Ins0', 'BMI', 'Glu0', 'DHEAS', 'T', 'FSH', 'LH', 'SHBG')
gmm.melt$variable <- factor(gmm.melt$variable, levels = c('Ins0', 'BMI', 'Glu0', 'DHEAS', 'T', 'FSH', 'LH', 'SHBG'))


ggplot(data = gmm.melt, aes(x=variable, y=value, fill=as.factor(cluster_id))) + geom_boxplot(outlier.shape = NA, coef = 0) +
  scale_fill_manual(labels = c("Metabolic", "Reproductive", "Background"), values=c(rgb(0.81,0.3,0.25,.85), rgb(.33,.5,.77,1), 'grey'), name = "") + ylim(-2,2) + 
  theme_bw() +
  theme(legend.position = "bottom", legend.box = "horizontal", 
        axis.title.x=element_blank()) + ylab("Z") + ggtitle("GMM")
```

```{r gmm_updatelabel, eval=TRUE, echo=FALSE, error=FALSE, message=TRUE}
## Re-order the data frame
col_idx <- grep("cluster_id", names(gmm_clusters))
gmm_clusters <- gmm_clusters[, c(col_idx, (1:ncol(gmm_clusters))[-col_idx])]
col_idx <- grep(sample, names(gmm_clusters))
gmm_clusters <- gmm_clusters[, c(col_idx, (1:ncol(gmm_clusters))[-col_idx])]

## Write output table
#write.csv(gmm_clusters, "path/to/Gmm_clusters.csv")
```

***
### PCA Plot of Cluster Results
```{r gmm_pca_plots, eval=TRUE, echo=FALSE, error=FALSE, message=TRUE}

################################################
# PCA plots overlay the clusters               #
################################################

### PCA PLOT ###
gmm_clusters$cluster_id <- as.factor(gmm_clusters$cluster_id)
gmm_clusters$group <- ifelse(gmm_clusters$cluster_id==1, "Metabolic", ifelse(gmm_clusters$cluster_id==2, "Reproductive", "Background"))

pca <- PCA(gmm_clusters[3:10], graph = F)

# If plot is mirrored from example, multiply PC1 by -1 to reverse image to
# maintain consistency.

#pca$ind$coord[,1] <- pca$ind$coord[,1]*-1
#pca$var$coord[,1] <- pca$var$coord[,1]*-1

fviz_pca_biplot(pca, col.ind = gmm_clusters$group, palette = c('grey', rgb(0.81,0.3,0.25,.85), rgb(.33,.5,.77,1)),
                addEllipses = TRUE, label = "var", col.var = "black", repel = TRUE,
                legend.title = "Subtype", pointsize=2,#pointshape=19,
                xlab = paste("PC1 (", round(pca$eig[1,2],2), '%)', sep=''),
                ylab = paste("PC2 (", round(pca$eig[2,2],2), '%)', sep=''),
                title = "GMM")
#dev.off()
```

```{r, gmm_compare clusters, echo=FALSE, error=FALSE, message=FALSE, warning=FALSE}
gmm_clusters = gmm_clusters %>% rename(gmm_group = group) 
cluster_compare <- merge(cluster_compare, gmm_clusters[c(1,11)], by='sample_id')
cluster_compare$gmm_group <- factor(cluster_compare$gmm_group, levels = c('Reproductive', 'Metabolic', 'Background'))

gmodels::CrossTable(cluster_compare$hc_group, cluster_compare$gmm_group, digits=2, prop.r = TRUE, prop.c =TRUE,
           prop.t= FALSE, prop.chisq = FALSE, chisq =FALSE, fisher =FALSE, missing.include=FALSE)

cluster_colors = c('#5480C4FF','#CF4D40D9','grey')

ggplot2::ggplot(cluster_compare, aes(fill = gmm_group, x=hc_group)) +
  geom_bar() +
  scale_fill_manual(values = cluster_colors) +
  ggtitle("HC Subtype Bars with GMM Subtype Color Fill")

ggplot2::ggplot(cluster_compare, aes(fill = gmm_group, x=km_group)) +
  geom_bar() +
  scale_fill_manual(values = cluster_colors) +
  ggtitle("Km Subtype Bars with GMM Subtype Color Fill")
```

## Compare 3 method of clustering
```{r compare cluster groups, echo=FALSE}

consensus = function(x, len=3) {
    temp = sort(table(x), decreasing=T)
    ifelse(temp[1]>len/2, names(temp)[1], NA)
}

cluster_compare = cbind(cluster_compare, consensus=apply(cluster_compare[c(10,11,13)], 1, consensus))

cluster_compare$consensus <- factor(cluster_compare$consensus, levels = c('Reproductive', 'Metabolic', 'Background'))

## Write output table
#write.csv(cluster_compare, "path/to/HC_Km_Gmm_clusters.csv")  
```

## Cross Tables- Consensus Result vs each method
```{r Consensus Crosstables, echo=FALSE, out.width="50%"}

gmodels::CrossTable(cluster_compare$consensus, cluster_compare$hc_group, digits=2, prop.r = TRUE, prop.c =TRUE,
           prop.t= FALSE, prop.chisq = FALSE, chisq =FALSE, fisher =FALSE, missing.include=FALSE)

gmodels::CrossTable(cluster_compare$consensus, cluster_compare$km_group, digits=2, prop.r = TRUE, prop.c =TRUE,
           prop.t= FALSE, prop.chisq = FALSE, chisq =FALSE, fisher =FALSE, missing.include=FALSE)

gmodels::CrossTable(cluster_compare$consensus, cluster_compare$gmm_group, digits=2, prop.r = TRUE, prop.c =TRUE,
           prop.t= FALSE, prop.chisq = FALSE, chisq =FALSE, fisher =FALSE, missing.include=FALSE)


gmodels::CrossTable(cluster_compare$hc_group, cluster_compare$km_group, digits=2, prop.r = TRUE, prop.c =TRUE,
           prop.t= FALSE, prop.chisq = FALSE, chisq =FALSE, fisher =FALSE, missing.include=FALSE)

```
## Visualize agreement of each method vs determined Consensus

```{r compare plots, echo= FALSE, out.width="33%"}
cluster_colors = c('#5480C4FF','#CF4D40D9','grey')

ggplot(cluster_compare, aes(fill = hc_group, x=consensus)) +
  geom_bar() +
  scale_fill_manual(values = cluster_colors) +
   ggtitle("Consensus vs HC Clustering")

ggplot(cluster_compare, aes(fill = km_group, x=consensus)) +
  geom_bar() +
  scale_fill_manual(values = cluster_colors) +
   ggtitle("Consensus vs Kmeans Clustering")

ggplot(cluster_compare, aes(fill = gmm_group, x=consensus)) +
  geom_bar() +
  scale_fill_manual(values = cluster_colors) +
  ggtitle("Consensus vs GMM Clustering")
```

## Breakdown of each method

```{r piecharts, echo=FALSE, out.width="33%"}

hc_cnt <- c(sum(cluster_compare$hc_group == 'Reproductive'),
            sum(cluster_compare$hc_group == 'Metabolic'), 
            sum(cluster_compare$hc_group == 'Background'))

hc_perc <- c(round(sum(cluster_compare$hc_group == 'Reproductive')/length(cluster_compare$hc_group),4)*100,
             round(sum(cluster_compare$hc_group == 'Metabolic')/length(cluster_compare$hc_group),4)*100,
             round(sum(cluster_compare$hc_group == 'Background')/length(cluster_compare$hc_group),4)*100)

km_cnt <- c(sum(cluster_compare$km_group == 'Reproductive'),
            sum(cluster_compare$km_group == 'Metabolic'), 
            sum(cluster_compare$km_group == 'Background'))

km_perc <- c(round(sum(cluster_compare$km_group == 'Reproductive')/length(cluster_compare$km_group),4)*100, 
             round(sum(cluster_compare$km_group == 'Metabolic')/length(cluster_compare$km_group),4)*100,
             round(sum(cluster_compare$km_group == 'Background')/length(cluster_compare$km_group),4)*100)

gmm_cnt <- c(sum(cluster_compare$gmm_group == 'Reproductive'), 
             sum(cluster_compare$gmm_group == 'Metabolic'), 
             sum(cluster_compare$gmm_group == 'Background'))

gmm_perc <- c(round(sum(cluster_compare$gmm_group == 'Reproductive')/length(cluster_compare$gmm_group),4)*100, 
              round(sum(cluster_compare$gmm_group == 'Metabolic')/length(cluster_compare$gmm_group),4)*100, 
              round(sum(cluster_compare$gmm_group == 'Background')/length(cluster_compare$gmm_group),4)*100)

tab <- rbind(hc_cnt,  km_cnt, gmm_cnt, hc_perc, km_perc, gmm_perc)
colnames(tab) <- c('Reproductive', 'Metabolic', 'Background')
rownames(tab) <- c('HC_Count', 'KM_Count', 'GMM_Count','HC_Percent', 'KM_Percent', 'GMM_Percent')

datatable(tab, options = list(dom = 't', columnDefs = list(list(className = 'dt-center', targets = 1:3))))

hc_perc = data.frame(hc_perc)
group = c('Reproductive', 'Metabolic', 'Background')
group <- factor(group, levels = c('Reproductive', 'Metabolic', 'Background'))
hc_perc = data.frame(hc_perc, group)

ggplot(hc_perc, aes(x="", y= hc_perc, fill= group)) +
  geom_col() +
  scale_fill_manual(values = c('#5480C4FF','#CF4D40D9','grey')) +
  coord_polar(theta = "y") +
  geom_text(aes(label = percent(hc_perc/100)), position = position_stack(vjust = 0.5)) +
  theme_void() +
  ggtitle("Hierarchical Clustering Subgroups")
  
km_perc = data.frame(km_perc)
group = c('Reproductive', 'Metabolic', 'Background')
group <- factor(group, levels = c('Reproductive', 'Metabolic', 'Background'))
km_perc = data.frame(km_perc, group)

ggplot(km_perc, aes(x="", y= km_perc, fill= group)) +
  geom_col() +
  scale_fill_manual(values = c('#5480C4FF','#CF4D40D9','grey')) +
  coord_polar(theta = "y") +
  geom_text(aes(label = percent(km_perc/100)), position = position_stack(vjust = 0.5)) +
  theme_void() +
  ggtitle("K-means Subgroups")

gmm_perc = data.frame(gmm_perc)
group = c('Reproductive', 'Metabolic', 'Background')
group <- factor(group, levels = c('Reproductive', 'Metabolic', 'Background'))
gmm_perc = data.frame(gmm_perc, group)

ggplot(gmm_perc, aes(x="", y= gmm_perc, fill= group)) +
  geom_col() +
  scale_fill_manual(values = c('#5480C4FF','#CF4D40D9','grey')) +
  coord_polar(theta = "y") +
  geom_text(aes(label = percent(gmm_perc/100)), position = position_stack(vjust = 0.5)) +
  theme_void() +
  ggtitle("Gaussian Mixed Model Subgroups")
```

### Plots of Individual traits by method
```{r boxplot 3_methods, echo=FALSE, out.width="33%"}

ggplot(data = cluster_compare, aes(y = BMI, x = hc_group, fill = hc_group)) + 
  geom_boxplot(fill=cluster_colors) +
  ggtitle("HC ") +
  xlab("") 
ggplot(data = cluster_compare, aes(y = BMI, x = km_group, fill = km_group)) + 
  geom_boxplot(fill=cluster_colors) +
  ggtitle("KMeans ") +
  xlab("") 
ggplot(data = cluster_compare, aes(y = BMI, x = gmm_group, fill = gmm_group)) + 
  geom_boxplot(fill=cluster_colors) +
  ggtitle("GMM ") +
  xlab("") 

ggplot(data = cluster_compare, aes(y = T, x = hc_group, fill = hc_group)) + 
  geom_boxplot(fill=cluster_colors) +
  ggtitle("HC ") +
  xlab("") 
ggplot(data = cluster_compare, aes(y = T, x = km_group, fill = km_group)) + 
  geom_boxplot(fill=cluster_colors) +
  ggtitle("KMeans ") +
  xlab("") 
ggplot(data = cluster_compare, aes(y = T, x = gmm_group, fill = gmm_group)) + 
  geom_boxplot(fill=cluster_colors) +
  ggtitle("GMM ") +
  xlab("") 

ggplot(data = cluster_compare, aes(y = DHEAS, x = hc_group, fill = hc_group)) + 
  geom_boxplot(fill=cluster_colors) +
  ggtitle("HC ") +
  xlab("") 
ggplot(data = cluster_compare, aes(y = DHEAS, x = km_group, fill = km_group)) + 
  geom_boxplot(fill=cluster_colors) +
  ggtitle("KMeans ") +
  xlab("") 
ggplot(data = cluster_compare, aes(y = DHEAS, x = gmm_group, fill = gmm_group)) + 
  geom_boxplot(fill=cluster_colors) +
  ggtitle("GMM ") +
  xlab("") 

ggplot(data = cluster_compare, aes(y = Ins0, x = hc_group, fill = hc_group)) + 
  geom_boxplot(fill=cluster_colors) +
  ggtitle("HC ") +
  xlab("") 
ggplot(data = cluster_compare, aes(y = Ins0, x = km_group, fill = km_group)) + 
  geom_boxplot(fill=cluster_colors) +
  ggtitle("KMeans ") +
  xlab("") 
ggplot(data = cluster_compare, aes(y = Ins0, x = gmm_group, fill = gmm_group)) + 
  geom_boxplot(fill=cluster_colors) +
  ggtitle("GMM ") +
  xlab("") 
ggplot(data = cluster_compare, aes(y = Glu0, x = hc_group, fill = hc_group)) + 
  geom_boxplot(fill=cluster_colors) +
  ggtitle("HC ") +
  xlab("") 
ggplot(data = cluster_compare, aes(y = Glu0, x = km_group, fill = km_group)) + 
  geom_boxplot(fill=cluster_colors) +
  ggtitle("KMeans ") +
  xlab("") 
ggplot(data = cluster_compare, aes(y = Glu0, x = gmm_group, fill = gmm_group)) + 
  geom_boxplot(fill=cluster_colors) +
  ggtitle("GMM ") +
  xlab("") 
ggplot(data = cluster_compare, aes(y = SHBG, x = hc_group, fill = hc_group)) + 
  geom_boxplot(fill=cluster_colors) +
  ggtitle("HC ") +
  xlab("") 
ggplot(data = cluster_compare, aes(y = SHBG, x = km_group, fill = km_group)) + 
  geom_boxplot(fill=cluster_colors) +
  ggtitle("KMeans ") +
  xlab("") 
ggplot(data = cluster_compare, aes(y = SHBG, x = gmm_group, fill = gmm_group)) + 
  geom_boxplot(fill=cluster_colors) +
  ggtitle("GMM ") +
  xlab("") 
ggplot(data = cluster_compare, aes(y = LH, x = hc_group, fill = hc_group)) + 
  geom_boxplot(fill=cluster_colors) +
  ggtitle("HC ") +
  xlab("") 
ggplot(data = cluster_compare, aes(y = LH, x = km_group, fill = km_group)) + 
  geom_boxplot(fill=cluster_colors) +
  ggtitle("KMeans ") +
  xlab("") 
ggplot(data = cluster_compare, aes(y = LH, x = gmm_group, fill = gmm_group)) + 
  geom_boxplot(fill=cluster_colors) +
  ggtitle("GMM ") +
  xlab("") 

ggplot(data = cluster_compare, aes(y = FSH, x = hc_group, fill = hc_group)) + 
  geom_boxplot(fill=cluster_colors) +
  ggtitle("HC ") +
  xlab("") 
ggplot(data = cluster_compare, aes(y = FSH, x = km_group, fill = km_group)) + 
  geom_boxplot(fill=cluster_colors) +
  ggtitle("KMeans ") +
  xlab("") 
ggplot(data = cluster_compare, aes(y = FSH, x = gmm_group, fill = gmm_group)) + 
  geom_boxplot(fill=cluster_colors) +
  ggtitle("GMM ") +
  xlab("") 
```

***
## Plot Traits of Consensus subjects and NA (non-Consensus)
```{r boxplots consensus, echo=FALSE}

con = cluster_compare[c(2:9, 14)]

con.melt <- melt(con, id.var = "consensus")
con.melt$consensus <- factor(con.melt$consensus, levels = c('Metabolic', 'Reproductive', 'Background'))

#sorted_vars <- var_labels
#plot_labels <- c('Ins0', 'BMI', 'Glu0', 'DHEAS', 'T', 'FSH', 'LH', 'SHBG')
con.melt$variable <- factor(con.melt$variable, levels = c('Ins0', 'BMI', 'Glu0', 'DHEAS', 'T', 'FSH', 'LH', 'SHBG'))


ggplot(data = con.melt, aes(x=variable, y=value, fill=as.factor(consensus))) + geom_boxplot(outlier.shape = NA, coef = 0) +
  scale_fill_manual(labels = c("Metabolic", "Reproductive", "Background"), values=c(rgb(0.81,0.3,0.25,.85), rgb(.33,.5,.77,1), 'grey'), name = "") + ylim(-3.4,3.4) +
  theme_bw() +
  theme(legend.position = "bottom", legend.box = "horizontal",
        axis.title.x=element_blank()) + ylab("Z") +
  ggtitle("Traits from Clustering Consensus")
```

***
### Strong Consensus 3 of 3 methods agree
```{r strong consensus, echo=FALSE, warning=FALSE}
str_consensus= cluster_compare %>% mutate(str_consensus=
  ifelse(hc_group=="Metabolic" & km_group=="Metabolic" & gmm_group=="Metabolic", "Metabolic",
         ifelse(hc_group=="Reproductive" & km_group=="Reproductive" & gmm_group=="Reproductive", "Reproductive",
                ifelse(hc_group=="Background" & km_group=="Background" & gmm_group=="Background", "Background", NA))))

str_consensus$str_consensus <- factor(str_consensus$str_consensus, levels = c('Reproductive', 'Metabolic', 'Background'))

## Write output table
#write.csv(str_consensus, "path/to/HC_Km_Gmm_Consensus_clusters.csv")  
```

```{r compare plots str, echo=FALSE, warning=FALSE, out.width="33%"}
cluster_colors = c('#5480C4FF','#CF4D40D9','grey')

ggplot(str_consensus, aes(fill = str_consensus, x=hc_group)) +
  geom_bar() +
  scale_fill_manual(values = cluster_colors) +
   ggtitle("Strong Consensus vs HC Clustering")

ggplot(str_consensus, aes(fill = str_consensus, x=km_group)) +
  geom_bar() +
  scale_fill_manual(values = cluster_colors) +
   ggtitle("Strong Consensus vs Kmeans Clustering")

ggplot(str_consensus, aes(fill = str_consensus, x=gmm_group)) +
  geom_bar() +
  scale_fill_manual(values = cluster_colors) +
  ggtitle("Strong Consensus vs GMM Clustering")
```

```{r boxplot strong consensus, echo=FALSE, warning=FALSE}

str_perc <- c(round(sum(str_consensus$str_consensus == "Reproductive", na.rm=TRUE)/length(str_consensus$str_consensus[!is.na(str_consensus$str_consensus)]),4)*100,
              round(sum(str_consensus$str_consensus == "Metabolic", na.rm=TRUE)/length(str_consensus$str_consensus[!is.na(str_consensus$str_consensus)]),4)*100, 
              round(sum(str_consensus$str_consensus == "Background", na.rm=TRUE)/length(str_consensus$str_consensus[!is.na(str_consensus$str_consensus)]),4)*100)

str_perc = data.frame(str_perc)
group = c('Reproductive', 'Metabolic', 'Background')
group <- factor(group, levels = c('Reproductive', 'Metabolic', 'Background'))
str_perc = data.frame(str_perc, group)

ggplot(str_perc, aes(x="", y= str_perc, fill= group)) +
  geom_col() +
  scale_fill_manual(values = c('#5480C4FF','#CF4D40D9','grey')) +
  coord_polar(theta = "y") +
  geom_text(aes(label = percent(str_perc/100)), position = position_stack(vjust = 0.5)) +
  theme_void() +
  ggtitle("Strong Consensus Subgroups")

str_con = str_consensus[c(2:9, 15)]

str_con.melt <- melt(str_con, id.var = "str_consensus")
str_con.melt$str_consensus <- factor(str_con.melt$str_consensus, levels = c('Metabolic', 'Reproductive', 'Background'))

str_con.melt$variable <- factor(str_con.melt$variable, levels = c('Ins0', 'BMI', 'Glu0', 'DHEAS', 'T', 'FSH', 'LH', 'SHBG'))

ggplot(data = str_con.melt, aes(x=variable, y=value, fill=as.factor(str_consensus))) + geom_boxplot(outlier.shape = NA, coef = 0) +
  scale_fill_manual(labels = c("Metabolic", "Reproductive", "Background"), values=c(rgb(0.81,0.3,0.25,.85), rgb(.33,.5,.77,1), 'grey'), name = "") + ylim(-2,2) + 
  theme_bw() +
  theme(legend.position = "bottom", legend.box = "horizontal", 
        axis.title.x=element_blank()) + ylab("Z") +
  ggtitle("Traits from Strong Consensus")

```

### Original PCA with non-consensus subjects indicated
```{r pca_plots2, eval=TRUE, echo=FALSE, error=FALSE, message=TRUE}

str_consensus$str_consensus <- factor(str_consensus$str_consensus, levels = c('Reproductive', 'Metabolic', 'Background', 'Non-Con'))
str_consensus$str_consensus = str_consensus$str_consensus %>% replace_na("Non-Con")
str(str_consensus)

pca <- PCA(str_consensus[2:9], graph = F)

# If plot is mirrored from example, multiply PC1 by -1 to reverse image to
# maintain consistency.

#pca$ind$coord[,1] <- pca$ind$coord[,1]*-1
#pca$var$coord[,1] <- pca$var$coord[,1]*-1

fviz_pca_biplot(pca, col.ind = str_consensus$str_consensus, palette = c('#5480C4FF', '#CF4D40D9', 'grey', 'mediumpurple'),
                addEllipses = TRUE, label = "var", col.var = "black", repel = TRUE,
                legend.title = "Subtype", pointsize=2,#pointshape=19,
                xlab = paste("PC1 (", round(pca$eig[1,2],2), '%)', sep=''),
                ylab = paste("PC2 (", round(pca$eig[2,2],2), '%)', sep=''),
                title = "")
#dev.off()
```
